<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ericlearns</title>
    <link>http://ericlearns.com/post/index.xml</link>
    <description>Recent content in Posts on ericlearns</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 19 May 2017 19:18:11 -0400</lastBuildDate>
    <atom:link href="http://ericlearns.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Build a Thing Friday: CSV Parser</title>
      <link>http://ericlearns.com/post/build-a-thing/</link>
      <pubDate>Fri, 19 May 2017 19:18:11 -0400</pubDate>
      
      <guid>http://ericlearns.com/post/build-a-thing/</guid>
      <description>&lt;p&gt;One of the keys to learning a new programming language is to &lt;em&gt;build&lt;/em&gt; things in the language you are trying to learn. Even if the thing is really small project or just a few lines of code, just keep writing code in the new language. With that in mind, I&amp;rsquo;m going to start what I&amp;rsquo;d like to call &amp;ldquo;Build a Thing Friday&amp;rdquo; where every Friday I try to build something small or large (probably small) in the language I am focusing on (C++ at this moment).&lt;/p&gt;

&lt;p&gt;One little project that I have been tinkering with in C++ is a CSV file parser. My day job sometimes requires me to work directly with CSV files, but almost always in Python. Wouldn&amp;rsquo;t it be fun to write a CSV parser in C++ though? Turns out it&amp;rsquo;s not the most fun I&amp;rsquo;ve had to do, but it was interesting. Admittedly, parsing a file with C++ felt a little like hammering a nail with a sledgehammer but maybe this would be useful if you were dealing with &lt;em&gt;massive&lt;/em&gt; CSV files. The complete code is at the bottom if you don&amp;rsquo;t want to read through everything.&lt;/p&gt;

&lt;p&gt;Anyways, let&amp;rsquo;s get started. I&amp;rsquo;ll create three files - &lt;code&gt;main.cpp&lt;/code&gt;, &lt;code&gt;parseIt.h&lt;/code&gt;, and &lt;code&gt;parseIt.cpp&lt;/code&gt;. Starting with the header file I&amp;rsquo;ll add a &lt;code&gt;class&lt;/code&gt; called &lt;code&gt;ParseCsv&lt;/code&gt; with a private member called &lt;code&gt;filePath&lt;/code&gt; and a public member function to set the file path for the file we want to work with.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;parseIt.h&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

class ParseCsv {
    private:
        std::string filePath;
    public:
        void setFilePath(std::string path);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s jump over to &lt;code&gt;parseIt.cpp&lt;/code&gt; and create the member function we added in the header file. &lt;code&gt;setFilePath&lt;/code&gt; will be a function that just takes a string argument and sets the private variable &lt;code&gt;filePath&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;parseIt.cpp&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;


void ParseCsv::setFilePath(std::string path) {
    filePath = path;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can move over to &lt;code&gt;main.cpp&lt;/code&gt; to add the header file and instantiate the class. We will also want to set the &lt;code&gt;filePath&lt;/code&gt; for the file we want to work with here. This can be any file, but I am using one called &lt;code&gt;data2.csv&lt;/code&gt; in my project root directory. It&amp;rsquo;s really important to set the file path here so our parser knows which file to grab. You&amp;rsquo;ll see pages of errors later if you forget to set &lt;code&gt;filePath&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;main.cpp&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;parseIt.h&amp;quot;


int main() {
    // instantiate and set file path
    ParseCsv parseCsv;
    parseCsv.setFilePath(&amp;quot;data2.csv&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, so now we get to the good stuff. Let&amp;rsquo;s work on the parser function itself. There are probably lots of different ways to do this, and mine is likely less than optimal but for now it works pretty good. The goal is to create a &lt;code&gt;2d vector&lt;/code&gt; where the inner vector represents a row of data in the CSV file. From there you can access each row, cell, or column by iterating the 2d vector. My personal goal was to get to the columns so I could perform analysis on the data within the columns e.g. counts, sum, averages, ect. In our header file we can add a member function for the parser, which takes no arguments but returns a 2d vector containing our CSV data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;parseIt.h&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;

class ParseCsv {
    private:
        std::string filePath;
    public:
        void setFilePath(std::string path);
        std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; parser();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our parser function is going to utilize the standard library string stream and file stream modules. We&amp;rsquo;ll use &lt;code&gt;ifstream&lt;/code&gt; to read the file. On my machine I run an older version of C++ so my &lt;code&gt;filePath&lt;/code&gt; string needs to be converted to &lt;code&gt;char&lt;/code&gt; using &lt;code&gt;c_str()&lt;/code&gt;, but this shouldn&amp;rsquo;t be an issue on newer versions of C++.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what we have so far for our parser function that returns a 2d vector:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; ParseCsv::parser() {
    std::ifstream file(filePath.c_str());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far we just read the file, but we&amp;rsquo;ll need a variable to represent each line of the file which will strings. We&amp;rsquo;ll also want to instantiate the 2d vector to hold our data that we&amp;rsquo;ll call &lt;code&gt;fullData&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; ParseCsv::parser() {
    std::ifstream file(filePath.c_str());
    std::string line;
    std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; fullData;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we need to get each line (or row) in the file. A &lt;code&gt;while&lt;/code&gt; loop is a good candidate for this, and C++&amp;rsquo;s &lt;code&gt;getline&lt;/code&gt; will allow us to iterate through the file until we reach the last line and gracefully exit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; ParseCsv::parser() {
    std::ifstream file(filePath.c_str());
    std::string line;
    std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; fullData;
    while (std::getline(file, line) {
        // todo ...
    }
    return fullData;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What this gets us is a string representation of each line in the CSV file. But what we&amp;rsquo;re really after is the &amp;ldquo;cells&amp;rdquo; or comma seperate values, which we can later access as columns. Inside the while loop we can operate on each line (row) of data by entering another while loop.&lt;/p&gt;

&lt;p&gt;Since we are going to be operating on strings, we can use &lt;code&gt;isstringstream&lt;/code&gt; to represent each line. We&amp;rsquo;ll also instantiate a string variable called &lt;code&gt;field&lt;/code&gt; that we&amp;rsquo;ll set in a moment. Most importantly, we can now create a new vector that will contain all of the data from the row in the second while loop. We&amp;rsquo;ll be using &lt;code&gt;getline&lt;/code&gt; again, but this time we are telling getline that we want the values between the commas by passing the optional delimiter argument &lt;code&gt;&#39;,&#39;&lt;/code&gt; (comma). As we loop we&amp;rsquo;ll push our results to the inner vector.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; ParseCsv::parser() {
    std::ifstream file(filePath.c_str());
    std::string line;
    std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; fullData;
    while (std::getline(file, line) {
        std::istringstream s(line);
        std::string field;
        std::vector&amp;lt;std::string&amp;gt; fullLine;
        while (std::getLine(s, field, &#39;,&#39;)) {
            fullLine.push_back(field);
        }
    }
    return fullData;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! So far we iterate through the file to get each line, then enter another while loop to get each cell on the line and push the cells on the line to their own vector. Now we just need to build the 2d array by pushing each line vector to the main &lt;code&gt;fullData&lt;/code&gt; 2d vector we instantiated earlier. We&amp;rsquo;ll need to push the new &lt;code&gt;fullLine&lt;/code&gt; vector after each iteration of the outer while loop.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; ParseCsv::parser() {
    std::ifstream file(filePath.c_str());
    std::string line;
    std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; fullData;
    while (std::getline(file, line) {
        std::istringstream s(line);
        std::string field;
        std::vector&amp;lt;std::string&amp;gt; fullLine;
        while (std::getLine(s, field, &#39;,&#39;)) {
            fullLine.push_back(field);
        }
        fullData.push_back(fullLine);
    }
    return fullData;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have the contents of the entire file parsed line by line and cell by cell into a 2d vector. I mentioned it above, but my goal was to get to a single column of data at a time, so let&amp;rsquo;s add a function for that. Basically, we just need to know which column index to get and then we can iterate the 2d vector, access the data, and store it in it&amp;rsquo;s own vector. We&amp;rsquo;ll add this new member function to our header file.&lt;/p&gt;

&lt;p&gt;This function will be called &lt;code&gt;singleCol&lt;/code&gt; and it will return a vector containing string values, as well at take a 2d vector and column number integer as arguments. Here is how our header file looks now:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;parseIt.h&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;

class ParseCsv {
    private:
        std::string filePath;
    public:
        void setFilePath(std::string path);
        std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; parser();
        std::vector&amp;lt;std::string&amp;gt; singleCol(std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; &amp;amp;fullFile, int colNum);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll iterate the 2d vector and access each &amp;ldquo;line&amp;rdquo; of the file, but only access elements in the inner vectors at the position specified by the &lt;code&gt;colNum&lt;/code&gt; argument. This will give us only the data from the given column at a time. We&amp;rsquo;ll go ahead and push this data to a new vector and return it. The left most column in your file is going to have an index (colNum) of zero and increase by one from there.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;std::vector&amp;lt;std::string&amp;gt; ParseCsv::singleCol(std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; &amp;amp;fullFile, int colNum) {
	std::vector&amp;lt;std::string&amp;gt; col;
	for (int i = 0; i &amp;lt; fullFile.size(); i++) {
		col.push_back(fullFile[i][colNum]);
	}
	return col;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can do whatever we want with the column data! But, remember there could be a header cell in the data, so be sure to account for that too. For parsing and access specific columns. So here is the final code for each of our three files. The program can be compiled using a command like:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;g++ main.cpp parseIt.cpp -o parser.exe&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;parseIt.h&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;

class ParseCsv {
    private:
        std::string filePath;
    public:
        void setFilePath(std::string path);
        std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; parser();
        std::vector&amp;lt;std::string&amp;gt; singleCol(std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; &amp;amp;fullFile, int colNum);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;parseIt.cpp&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;parseIt.h&amp;quot;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;fstream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;


void ParseCsv::setFilePath(std::string path) {
    filePath = path;
}

std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; ParseCsv::parser() {
    std::ifstream file(filePath.c_str());
    std::string line;
    std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; fullData;
    while (std::getline(file, line) {
        std::istringstream s(line);
        std::string field;
        std::vector&amp;lt;std::string&amp;gt; fullLine;
        while (std::getLine(s, field, &#39;,&#39;)) {
            fullLine.push_back(field);
        }
        fullData.push_back(fullLine);
    }
    return fullData;
}

std::vector&amp;lt;std::string&amp;gt; ParseCsv::singleCol(std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; &amp;amp;fullFile, int colNum) {
	std::vector&amp;lt;std::string&amp;gt; col;
	for (int i = 0; i &amp;lt; fullFile.size(); i++) {
		col.push_back(fullFile[i][colNum]);
	}
	return col;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;main.cpp&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;parseIt.h&amp;quot;


int main() {
    // instantiate and set file path
    ParseCsv parseCsv;
    parseCsv.setFilePath(&amp;quot;data2.csv&amp;quot;);

    // parse file and select certain column
    std::vector&amp;lt;std::vector&amp;lt;std::string&amp;gt; &amp;gt; parsed = parseCsv.parser();
    std::vector&amp;lt;std::string&amp;gt; firstCol = parseCsv.singleCol(parsed, 0);

    // print a column
    for (int i = 0; i &amp;lt; firstCol.size(); i++) {
        std::cout &amp;lt;&amp;lt; firstCol[i] &amp;lt;&amp;lt; std::endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, that wasn&amp;rsquo;t so bad! I think I&amp;rsquo;ll expand on this little program in the next few weeks by adding some functions for data analyis&amp;hellip;oooh exciting! Maybe on the next edition of Build a Thing Friday?! Could come in handy anyways.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>References in C&#43;&#43;</title>
      <link>http://ericlearns.com/post/cpp_references/</link>
      <pubDate>Wed, 17 May 2017 06:47:07 -0400</pubDate>
      
      <guid>http://ericlearns.com/post/cpp_references/</guid>
      <description>&lt;p&gt;Another new C++ concept, references! I recently google &lt;code&gt;C++ references&lt;/code&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Reference_(C%2B%2B)&#34;&gt;found&lt;/a&gt; the following definition&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The definition of a reference in C++ is such that it does not need to exist.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What in the actual fuck does that even mean? I have no idea. Maybe it&amp;rsquo;s just a bad definition (likely), or maybe it will make more sense later. Anyways, on to references. A reference in C++ is defined with an ampersand &lt;code&gt;&amp;amp;&lt;/code&gt; as well as the type and name, but the &lt;code&gt;&amp;amp;&lt;/code&gt; is not used again after the variable has been defined.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt; int &amp;amp;myRef
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But if you popped the above variable declaration into a program and compiled it, you would be greeted with the following message&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;error: &amp;lsquo;myRef&amp;rsquo; declared as reference but not initialized&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;reference&lt;/code&gt; needs to &lt;em&gt;reference&lt;/em&gt; something. Let&amp;rsquo;s give it something to refer to, and create a little program below to keep track of things and actually do something. The code below &lt;em&gt;will&lt;/em&gt; compile, but it&amp;rsquo;s not really doing anything meaningful just yet. If you go ahead and compile the program and run the executable you should get two lines of identical output. What it&amp;rsquo;s showing you is &lt;code&gt;myVar&lt;/code&gt;&amp;rsquo;s memory location, and that the reference variable &lt;code&gt;myVarRef&lt;/code&gt; is basically now a second label for that memory location.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

int main() {
    int myVar;
    int &amp;amp;myVarRef = myVar;

    std::cout &amp;lt;&amp;lt; myVar &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; myVarRef &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can go ahead and give the same code above some values to work with. Compiling this program and running the executable will result in two identical lines again, but this time with the actual value, 500 in this case, for both the referencee and referencer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

int main() {
    int myVar = 500;
    int &amp;amp;myVarRef = myVar;

    std::cout &amp;lt;&amp;lt; myVar &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; myVarRef &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;500
500
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is where things get interesting. If we change the value of &lt;code&gt;myVarRef&lt;/code&gt;, something I was not expecting to happen to &lt;code&gt;myVar&lt;/code&gt; happens.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

int main() {
	int myVar = 500;
	int &amp;amp;myVarRef = myVar;

	std::cout &amp;lt;&amp;lt; &amp;quot;Original value of myVar: &amp;quot; &amp;lt;&amp;lt; myVar &amp;lt;&amp;lt; std::endl;

	myVarRef = 20;
	std::cout &amp;lt;&amp;lt; &amp;quot;Value of myVar after changing the reference value: &amp;quot; &amp;lt;&amp;lt; myVar &amp;lt;&amp;lt; std::endl;
	std::cout &amp;lt;&amp;lt; &amp;quot;Reference var value: &amp;quot; &amp;lt;&amp;lt; myVarRef &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Original value of myVar: 500
Value of myVar after changing the reference value: 20
Reference var value: 20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The original value of &lt;code&gt;myVar&lt;/code&gt; was changed when I changed the value of the reference variable! Holy crap. So the original variable and the reference variable both refer to the same value and as such, you can perform the same operations through the reference variable as you could with the original. That is amazing.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try to expand on this and change the value of &lt;code&gt;myVar&lt;/code&gt;. I&amp;rsquo;m curious to see what impact that will have on &lt;code&gt;myVarRef&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

int main() {
	int myVar = 500;
	int &amp;amp;myVarRef = myVar;

	std::cout &amp;lt;&amp;lt; &amp;quot;Original value of myVar: &amp;quot; &amp;lt;&amp;lt; myVar &amp;lt;&amp;lt; std::endl;

	myVarRef = 20;
	std::cout &amp;lt;&amp;lt; &amp;quot;Value of myVar after changing the reference value: &amp;quot; &amp;lt;&amp;lt; myVar &amp;lt;&amp;lt; std::endl;
	std::cout &amp;lt;&amp;lt; &amp;quot;Reference var value: &amp;quot; &amp;lt;&amp;lt; myVarRef &amp;lt;&amp;lt; std::endl;

	myVar = 200;
	std::cout &amp;lt;&amp;lt; &amp;quot;Value of myVar after changing it&#39;s value: &amp;quot; &amp;lt;&amp;lt; myVar &amp;lt;&amp;lt; std::endl;
	std::cout &amp;lt;&amp;lt; &amp;quot;Update reference var value: &amp;quot; &amp;lt;&amp;lt; myVarRef &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Value of myVar after changing the reference value: 20
Reference var value: 20
Value of myVar after changing it&#39;s value: 200
Update reference var value: 200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So that changes the values going both ways! Ok, great. But when am I actually going to use this? For one thing, it&amp;rsquo;s really handy when passing arguments to functions. When you do not include the argument as a reference, you are &lt;code&gt;passing by value&lt;/code&gt; and depending on the size this can be very expensive and slow down your program. Using a reference in your argument, you are &lt;code&gt;passing by reference&lt;/code&gt; which is much more memory efficient.&lt;/p&gt;

&lt;p&gt;Couldn&amp;rsquo;t we just use pointers instead of references? Well, yeah but one major difference is that the compiler handles allocating and deallocating memory for references, but it does not do this pointers. Memory management is up to you when using pointers. Probably pros and cons to that difference, but I think using references also helps with the always important code readability.&lt;/p&gt;

&lt;p&gt;Let me revisit that C++ references definition from the very beginning of this post really quick. Does it make sense now? Hell no. This is a bad definition in my opinion. I would define C++ references as&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An alias (or another name) for an existing variable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;More to come on references. I&amp;rsquo;ll be trying to include them more and more in my code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Understanding Selection Sort</title>
      <link>http://ericlearns.com/post/selection_sort/</link>
      <pubDate>Mon, 15 May 2017 06:50:06 -0400</pubDate>
      
      <guid>http://ericlearns.com/post/selection_sort/</guid>
      <description>&lt;p&gt;Alright selection sort algorithm, let&amp;rsquo;s dance.&lt;/p&gt;

&lt;p&gt;This algorithm is one type of many sorting algorithms used to sort values in an array. While I &lt;em&gt;understand&lt;/em&gt; how it works it might be a little hard to put into words, but I&amp;rsquo;ll give it a go either way. The main idea is that you start at the first index in an array (usually always 0), then compare it to the element in the next index position. If the element in the next index position is larger than the previous than you check that element against the rest of the elements in the array to see if a smaller element exists. If no smaller element exists then you &lt;em&gt;swap&lt;/em&gt; the positions and repeat the process for the next element until the list is sorted. Phew.&lt;/p&gt;

&lt;p&gt;Here is a quick visual tour. We&amp;rsquo;ll start with the following array (or list if you&amp;rsquo;re into Python)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[18, 19, 66, 44, 9, 22, 14]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we&amp;rsquo;ll start with index 0, which is 18.&lt;/p&gt;

&lt;p&gt;Is 18 larger than the next element after 18, which is 19? Nope.&lt;/p&gt;

&lt;p&gt;Is 18 larger than the next element after 19, which is 66? Nope.&lt;/p&gt;

&lt;p&gt;Is 18 larger than the next element after 66, which is 44? Nope.&lt;/p&gt;

&lt;p&gt;Is 18 larger than the next element after 44, which is 9? Yep!&lt;/p&gt;

&lt;p&gt;Ok, this is where things get interesting. Since 18 is larger than 9, we now we need check if any other elements in the list are larger than 9. But we already know that the elements so far &lt;em&gt;must&lt;/em&gt; greater than 18 or we wouldn&amp;rsquo;t have gotten so far. With that in mind, we only need to check the elements to the right of 9 to ensure that 9 is the smallest. Let&amp;rsquo;s do that.&lt;/p&gt;

&lt;p&gt;Is 9 larger than the next element after 9, which is 22? Nope.&lt;/p&gt;

&lt;p&gt;Is 9 larger than the next element after 22, which is 14? Nope.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve reached the end of our array. At this point we now know that 9 is the smallest number, so we need to &lt;em&gt;swap&lt;/em&gt; the first element, 18, with 9. Once we&amp;rsquo;ve made the swap, we can move to the next element and repeat the steps again. Our array now looks as follows&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[9, 19, 66, 44, 18, 22, 14]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We should go through the steps again one more time with the next element just to be sure this is all making sense.&lt;/p&gt;

&lt;p&gt;We are now at index 1, which is 19 now since we performed a &lt;em&gt;swap&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Is 19 larger than the next element after 19, which is  66?  Nope.&lt;/p&gt;

&lt;p&gt;Is 19 larger than the next element after 66, which is  44? Nope.&lt;/p&gt;

&lt;p&gt;Is 19 larger than the next element after 44, which is  18? Yep!&lt;/p&gt;

&lt;p&gt;Ding ding ding! Now we check everything after 18 to see if 18 is the smallest.&lt;/p&gt;

&lt;p&gt;Is 18 larger than the next element after 18, which is  22? Nope.&lt;/p&gt;

&lt;p&gt;Is 18 larger than the next element after 22, which is  14? Yep!&lt;/p&gt;

&lt;p&gt;Now check to see if 14 is the smallest&amp;hellip;.but wait! 14 is the last element, so it has to be the next smallest after 9. We&amp;rsquo;ll make another swap and restart the process again with index 2, 66. Our array now looks as follows&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[9, 14, 66, 44, 18, 22, 19]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s pretty cool if you ask me. With that terrible explanation out of the way, let&amp;rsquo;s take a look at how this is actually implemented and hopefully that will help clarify. Let me add a big &lt;em&gt;NOTE&lt;/em&gt; here that you should run this code in a debugger with a breakpoint set so you can step through each line and see what&amp;rsquo;s actually happening. I found this to be the most helpful way of actually understanding this algorithm. Text explanations really don&amp;rsquo;t do a great job or clarifying what is actually happening, even though this explanation is clearly top notch.&lt;/p&gt;

&lt;p&gt;I am going to show this first in Python. In selection sort we are mostly going to be working with list indexes, so we&amp;rsquo;ll use a &lt;code&gt;for loop&lt;/code&gt; with &lt;code&gt;range&lt;/code&gt; based on the length of the unsorted list&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sel_sort(unsorted_list):
    for i in range(len(unsorted_list)):
        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are going to need to increment the index &lt;code&gt;i&lt;/code&gt; when we find larger elements in the list. Probably not a good idea to change the value of &lt;code&gt;i&lt;/code&gt; directly in this case, so we&amp;rsquo;ll set a variable to represent the minimum index value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sel_sort(unsorted_list):
    for i in range(len(unsorted_list)):
        min_index = i
        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All of the elements to the right of &lt;code&gt;min_index&lt;/code&gt; we can consider to be in a &lt;code&gt;sub list&lt;/code&gt; or &lt;code&gt;sub array&lt;/code&gt; that we&amp;rsquo;ll need to iterate over and check. We&amp;rsquo;ll create another &lt;code&gt;for loop&lt;/code&gt; inside of our first to check these elements and update &lt;code&gt;min_index&lt;/code&gt; as needed. &lt;em&gt;But&lt;/em&gt;, we only want to check elements one index position to the right of &lt;code&gt;min_index&lt;/code&gt; so we need to increment &lt;code&gt;i&lt;/code&gt; in our next loop to start at the next position. This is what creates our &lt;code&gt;sub list&lt;/code&gt;. Note the &lt;code&gt;range(i+1, len(unsorted_list))&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sel_sort(unsorted_list):
    for i in range(len(unsorted_list)):
        min_index = i
        for j in range(i+1, len(unsorted_list)):
            current_elem = nums[min_index]
            next_elem = nums[j]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can perform the greater than check and decide if we need to move to the next element or not.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sel_sort(unsorted_list):
    for i in range(len(unsorted_list)):
        min_index = i
        for j in range(i+1, len(unsorted_list)):
            current_elem = unsorted_list[min_index]
            next_elem = unsorted_list[j]
            if current_elem &amp;gt; next_elem:
                min_index = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason I created the variables &lt;code&gt;current_elem&lt;/code&gt; and  &lt;code&gt;next_elem&lt;/code&gt; is for debugging purposes. Everything makes more sense when stepping through the code if you set a variable to represent the values that you can see in the debugger.&lt;/p&gt;

&lt;p&gt;There is one important portion of this algorithm we should take a closer look at now, and that is the &lt;em&gt;swap&lt;/em&gt;. In Python, swapping elements in a list is as simple as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# swap first and second elements in a list
my_list[0], my_list[1] = my_list[1], my_list[0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But in other languages, specifically C++, we need an extra variable to hold the value of the first item. I&amp;rsquo;ll represent this in Python here because later you&amp;rsquo;ll see it in the C++ selection sort example. So here is the full selection sort algorithm implemented in Python.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sel_sort(unsorted_list):
    for i in range(len(unsorted_list)):
        min_index = i
        for j in range(i+i, len(unsorted_list)):
            current_elem = unsorted_list[min_index]
            next_elem = unsorted_list[j]
            if current_elem &amp;gt; next_elem:
                min_index = 1
        tmp = unsorted_list[i]
        unsorted_list[i] = unsorted_list[min_index]
        unsorted_list[min_index] = tmp
    return unsorted_list

nums = [18, 19, 66, 44, 9, 22, 14]
print sel_sort(nums)

# prints [9, 14, 18, 19, 22, 44, 66]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And there you have it. Below is an example of selection sort in C++. This example creates a copy of the vector, mostly because I don&amp;rsquo;t know how to do it a better way yet. Soon.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

std::vector&amp;lt;int&amp;gt; selectSort(std::vector&amp;lt;int&amp;gt; myVec) {
    for (int i = 0; i &amp;lt; myVec.size(); i++) {
        int minIndex = i;
        for (int j = i + 1; j &amp;lt; myVec.size(); j++) {
            if (myVec[minIndex] &amp;gt; myVec[j]) {
                minIndex = j;
            }
        }
        int tmp = myVec[i];
        myVec[i] = myVec[minIndex];
        myVec[minIndex] = tmp;
    }
    return myVec;
}

int main() {
    std::vector&amp;lt;int&amp;gt; vec {6, 55, 22, 4, 1, 88};
    std::vector&amp;lt;int&amp;gt; myVecSorted = selectSort(vec);
    for (int i = 0; i &amp;lt; myVecSorted.size(); i++) {
        std::cout &amp;lt;&amp;lt; myVecSorted[i] &amp;lt;&amp;lt; std::endl;
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what&amp;rsquo;s the efficieny of the selection sort algorithm? As the length of your array grows, so does the time complexity. For this algorithm, the time complexity in big O notation is &lt;code&gt;0(n^2)&lt;/code&gt;. Did I just google that and paste it in here without fully understanding it? I sure did. Another post soon on time and space complexity.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Quick Intro to Classes in C&#43;&#43;</title>
      <link>http://ericlearns.com/post/classes_intro/</link>
      <pubDate>Mon, 15 May 2017 06:43:48 -0400</pubDate>
      
      <guid>http://ericlearns.com/post/classes_intro/</guid>
      <description>&lt;p&gt;Classes are a powerful data structure in C++ (and many other programming languages). But classes in C++ are a bit different from classes in Python, or even JavaScript (gasp) if that&amp;rsquo;s your thing. C++ allows you to set &lt;code&gt;private&lt;/code&gt; members in your class that can only be accessed by member functions in the class. This is really handy for a few reasons, one of them being if you need to change the value or behavior of a private member you can do so without breaking every member function that uses that private member. The concept of changing the value of private members is called &lt;code&gt;getting and setting&lt;/code&gt;. Getting and setting exists in Python, but it is not as common of a pattern as in C++.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s go through a really simple class example to get the idea of how this data structure works in C++. I am going to create three files- &lt;code&gt;main.cpp&lt;/code&gt;, &lt;code&gt;pracClass.cpp&lt;/code&gt;, and &lt;code&gt;pracClass.h&lt;/code&gt;. In this simple example I am going to create a class to represent a bank, and it will contain some methods to handle transactions. In &lt;code&gt;pracClass.h&lt;/code&gt; I&amp;rsquo;ll go ahead and create the class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

class Bank {
    private:
        int balance;
    public:
        // todo - add public members
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have created our class with a private member &lt;code&gt;balance&lt;/code&gt; whos value can only be set by members of the Bank class. In &lt;code&gt;pracClass.cpp&lt;/code&gt; we can go ahead and create a member function to set the value for &lt;code&gt;balance&lt;/code&gt; as needed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;quot;pracClass.h&amp;quot;

void Bank::setBalance(int amt) {
    balance = amt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we&amp;rsquo;ll add it to our Bank class as a member function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

class Bank {
    private:
        int balance;
    public:
        void setBalance(int amt);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It would be nice if we could see what the balance is at any given time, so I&amp;rsquo;ll go ahead and add another member function that prints the balance to standard out. In &lt;code&gt;pracClass.cpp&lt;/code&gt; I&amp;rsquo;ll add the function &lt;code&gt;printBalance&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;quot;pracClass.h&amp;quot;

void Bank::setBalance(int amt) {
    balance = amt;
}

void Bank::printBalance() {
    std::cout &amp;lt;&amp;lt; &amp;quot;Balance: $&amp;quot; &amp;lt;&amp;lt; balance &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And add the new member function to the Bank class&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

class Bank {
    private:
        int balance;
    public:
        void setBalance(int amt);
        void printBalance();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we can add a member function for making a withdrawl and making a deposit, which we&amp;rsquo;ll call &lt;code&gt;makeWithdrawl&lt;/code&gt; and &lt;code&gt;makeDeposit&lt;/code&gt; respectively and add them to &lt;code&gt;printClass.cpp&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;quot;pracClass.h&amp;quot;

void Bank::setBalance(int amt) {
    balance = amt;
}

void Bank::printBalance() {
    std::cout &amp;lt;&amp;lt; &amp;quot;Balance: $&amp;quot; &amp;lt;&amp;lt; balance &amp;lt;&amp;lt; std::endl;
}

void Bank::makeWithdrawl(int amt) {
    balance -= amt;
}

void Bank::makeDeposit(int amt) {
    balance += amt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding both of these new member functions to the Bank class in our header file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

class Bank {
    private:
        int balance;
    public:
        void setBalance(int amt);
        void printBalance();
        void makeWithdrawl(int amt);
        void makeDeposit(int amt);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, this is a really simply example so I am going to the leave the member functions as they are and assume they won&amp;rsquo;t be passed an int value that will result in an error. But, we should really consider some scenarios that &lt;em&gt;could&lt;/em&gt; break e.g. withdrawing more money than available. Maybe an exception could be thrown for that case? For now, they are ok as-is to illustrate the basics of classes.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll switch over to our &lt;code&gt;main.cpp&lt;/code&gt; file and start using our Bank class. First we&amp;rsquo;ll create an instance of the Bank class called &lt;code&gt;myBank&lt;/code&gt;, then we&amp;rsquo;ll set the balance in our account. This is where the &lt;code&gt;private&lt;/code&gt; member really shines. We can set the balance to be whatever we want at any given time, and someone else using the class can set the balance to a completely different value if they needed to without effecting us. That is pretty awesome!&lt;/p&gt;

&lt;p&gt;An important point here is that &lt;em&gt;do&lt;/em&gt; need to actually set the value for the balance though. If we forgot to do this we&amp;rsquo;d get an integer we weren&amp;rsquo;t expecting, the memory space representation for the variable.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;main.cpp&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;quot;pracClass.h&amp;quot;

int main() {
    Bank myBank;
    myBank.setBalance(0);
    myBank.printBalance();

    myBank.makeDeposit(150);
    myBank.printBalance();

    myBank.makeWithdrawl(100);
    myBank.printBalance();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the command line we can compile this program with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;g++ prac_class.cpp main.cpp -o bank.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running &lt;code&gt;bank.exe&lt;/code&gt; results in the output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Balance: $0
Balance: $150
Balance: $50
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Classes in C++ can obviously get much more complex than this and I&amp;rsquo;ll probably do a post soon on inheritance in C++, but this quick example shows just how flexible and powerful of a data structure they can be and how private members provide &lt;code&gt;encapsulation&lt;/code&gt; for your program.&lt;/p&gt;

&lt;p&gt;But what about Python?! Well, there are no public or private attributes in Python. You could add an underscore to your variable name, but it does nothing more than signal to the user that you &lt;em&gt;intend&lt;/em&gt; for this variable to private, they can still access or modify it however they like. Python does allow &lt;code&gt;@property&lt;/code&gt; decorators for getters and setters, but this is not a common pattern. Anyways, here&amp;rsquo;s an similar example written in Python.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Bank(object):

    def __init__(self, balance):
        self.balance = balance

    def make_deposit(self, amt):
        self.balance += amt

    def make_withdrawl(self, amt):
        self.balance -= amt

    def print_balance(self):
        print &#39;Balance: ${}&#39;.format(self.balance)


my_bank = Bank(0)
my_bank.print_balance()

# oh crap, the attribute value changed
my_bank.balance = 200

my_bank.make_deposit(100)
my_bank.print_balance()

my_bank.make_withdrawl(50)
my_bank.print_balance()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which outputs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Balance: $0
Balance: $300
Balance: $250
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Binary Search Example</title>
      <link>http://ericlearns.com/post/binary-search-example/</link>
      <pubDate>Wed, 10 May 2017 06:18:05 -0400</pubDate>
      
      <guid>http://ericlearns.com/post/binary-search-example/</guid>
      <description>&lt;p&gt;I want to talk about &lt;code&gt;logarithms&lt;/code&gt; briefly to lay some of the ground work for Binary Search. What is a logarithm exactly? At a basic level it&amp;rsquo;s how times we can multiply a number to get another number. For example, how many times can we multiply 2 to get 8? 3 times.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2 x 2 x 2 = 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, that makes sense but what does it have to do with Binary Search? Binary Search is essentially searching for an element in an list by cutting the list in half multiple times to narrow in on the target. So, if we look at the logarithm question above another way- if we had an array of length 8, how many times can it be cut in half?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[1, 2, 3, 4, 5, 6, 7, 8]  # starting point
[5, 6, 7, 8]  # cut in half once
[7, 8]  # cut in half twice
[8]  # cut in half a third time
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we wanted to know if the number 7 was in the list above, using binary search it would take us &lt;em&gt;at worst&lt;/em&gt; 4 or &lt;code&gt;log(8) + 1&lt;/code&gt; (including first guess) guesses to determine which index the 7 was at or if it was in the list at all. Written another way  in Python using the list above, it would take us at worst &lt;code&gt;log(len(my_nums)) + 1&lt;/code&gt; guesses.&lt;/p&gt;

&lt;p&gt;One of the most important requirements of binary search is that your list &lt;em&gt;must&lt;/em&gt; be sorted. The reason for this is because you will always start with a first guess that the middle element of your list is your target, and if it&amp;rsquo;s not you need to know if you should search left (larger) or right (smaller) of the middle next. The next element to the left &lt;em&gt;must&lt;/em&gt; be greater than or equal to the target, and the element next to the right &lt;em&gt;must&lt;/em&gt; less than or equal to the target.&lt;/p&gt;

&lt;p&gt;So, lets talk through the steps a little bit. We have a sorted list with 8 numbers in it, and the number are checking for (our target) is going to be 13.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;target = 13
my_nums = [1, 3, 5, 6, 11, 13, 17, 21]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first element in a list is always going to be at index 0, so we create a variable to represent the starting point that will be updated as we search through the list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;target = 13
my_nums = [1, 3, 5, 6, 11, 13, 17, 21]
min_index = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need to know what the index of the last element in our list is. Since lists start with an index of 0, we can assume that the last index is going to be the length of list (8 in this case) minus 1.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;target = 13
my_nums = [1, 3, 5, 6, 11, 13, 17, 21]
min_index = 0
max_index = len(my_nums) -1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we are going to need to keep making guesses until we find the target in the list or we determine that the target is not in the list. A &lt;code&gt;while&lt;/code&gt; loop is probably a good candidate for making repeated guess until a condition is met.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;target = 13
my_nums = [1, 3, 5, 6, 11, 13, 17, 21]
min_index = 0
max_index = len(my_nums) -1
while True:
    # todo do some checking
    break
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s set a variable to represent our first guess, the middle element in our list. How do we get the middle element in our list? We can assume that it is going to be the &lt;code&gt;min_index&lt;/code&gt; plus the &lt;code&gt;max_index&lt;/code&gt; divided in half, which is index 3 in our example. We&amp;rsquo;ll represent the first guess as a variable called &lt;code&gt;index_guess&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;target = 13
my_nums = [1, 3, 5, 6, 11, 13, 17, 21]
min_index = 0
max_index = len(my_nums) -1
while True:
    index_guess = (min_index + max_index)/2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s do an equality check to see if our first guess was correct.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;target = 13
my_nums = [1, 3, 5, 6, 11, 13, 17, 21]
min_index = 0
max_index = len(my_nums) -1
while True:
    index_guess = (min_index + max_index)/2
    if my_nums[index_guess] == target:
        print &#39;found the target at index &#39;, index_guess
        break
    break
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we were lucky enough to have our first guess be correct, then we&amp;rsquo;d get a nice output to congratulate us on our success. Unfortunately, we are not going to be so lucky today and we need to search again. Let&amp;rsquo;s check if the target is larger or than our first guess.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;target = 13
my_nums = [1, 3, 5, 6, 11, 13, 17, 21]
min_index = 0
max_index = len(my_nums) -1
while True:
    index_guess = (min_index + max_index)/2
    if target == my_nums[index_guess]:
        print &#39;found the target at index &#39;, index_guess
        break
    elif target &amp;gt; search_list[index_guess]:
        # todo decide where to look next
        print &#39;larger&#39;
        break
    break
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is where binary search gets really interesting and efficient! Since our target is larger than the middle index in this case, we are guaranteed that our target will not be to the left of &lt;code&gt;index_guess&lt;/code&gt; and we can ignore all of those values and focus on the values to the right. This eliminates searching in half of the list! Pretty cool. This also illustrates why a sorted list for binary search is so crucial. You cannot make any guarantees about the next element to check with an unsorted list.&lt;/p&gt;

&lt;p&gt;So at this point our target is larger than our first guess, so we need to check again but we only care about checking values to the right now. We also know that the middle index value is not a match, so let&amp;rsquo;s increment our &lt;code&gt;min_index&lt;/code&gt; to be one index position larger than our first guess. If you can picture it, we are basically sliding our search window over to the right by one index position.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;target = 13
my_nums = [1, 3, 5, 6, 11, 13, 17, 21]
min_index = 0
max_index = len(my_nums) -1
while True:
    index_guess = (min_index + max_index)/2
    if target == my_nums[index_guess]:
        print &#39;found the target at index &#39;, index_guess
        break
    elif target &amp;gt; my_nums[index_guess]:
        print &#39;larger&#39;
        min_index = index_guess + 1
    break
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our target was larger than our first guess, but our target could be smaller than our next guess so we need to handle that situation. If the target is smaller than our guess then we need to check the next index position to the left, or one minus &lt;code&gt;index_guess&lt;/code&gt;. I&amp;rsquo;ll also remove the additional &lt;code&gt;break&lt;/code&gt; statement at this point so our &lt;code&gt;while&lt;/code&gt; loop will keep checking.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;target = 13
my_nums = [1, 3, 5, 6, 11, 13, 17, 21]
min_index = 0
max_index = len(my_nums) -1
while True:
    index_guess = (min_index + max_index)/2
    if target == my_nums[index_guess]:
        print &#39;found the target at index &#39;, index_guess
        break
    elif target &amp;gt; my_nums[index_guess]:
        print &#39;larger&#39;
        min_index = index_guess + 1
    elif target &amp;lt; my_nums[index_guess]:
        print &#39;smaller&#39;
        max_index = index_guess - 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As this binary search algorithm is defined above, the target will be found at index 5. But what if we are searching for a target that is not in the list? The &lt;code&gt;while&lt;/code&gt; loop is going to keep executing and we&amp;rsquo;ll be stuck in an infinite loop. While this is happening, our &lt;code&gt;min_index&lt;/code&gt; value is going to keep increasing and eventually become greater than the value for &lt;code&gt;max_index&lt;/code&gt;. When our &lt;code&gt;min_index&lt;/code&gt; is larger than our &lt;code&gt;max_index&lt;/code&gt; we can be sure that our target is not in the list and we can break out of the loop. Lets add a check for this condition.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;target = 13
my_nums = [1, 3, 5, 6, 11, 13, 17, 21]
min_index = 0
max_index = len(my_nums) -1
while True:
    index_guess = (min_index + max_index)/2
    if max_index &amp;lt; min_index:
        print &#39;not in list&#39;
        break
    elif target == my_nums[index_guess]:
        print &#39;found the target at index &#39;, index_guess
        break
    elif target &amp;gt; my_nums[index_guess]:
        print &#39;larger&#39;
        min_index = index_guess + 1
    elif target &amp;lt; my_nums[index_guess]:
        print &#39;smaller&#39;
        max_index = index_guess - 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What will happen to our performance as the size of the list increases? Our performance will decrease, and it will decrease a specific rate. Right now our 8 element list has a worst case scenario of 4 guesses to find the target. What if we doubled the length of our list?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]  # first guess
[9, 10, 11, 12, 13, 14, 15, 16]  # cut in half once
[13, 14, 15, 16]  # cut in half twice
[15, 16]  # cut in half three times
[16]  # cut in half a final fourth time
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we double the length of the list we add a guess, and now we have a worst case of 5 guesses to get our target element. This pattern continues as you add more elements to the list. If our first guess is a match then we remain in constant time, but if not our runtime in big-o notation is going to be &lt;code&gt;O(log(n))&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Just for fun, here is binary search implemented in C++ and using strings instead of integers in the search vector. I also included a &lt;code&gt;guesses&lt;/code&gt; variable to keep track of how many guess it took to find the target.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

void binarySearch(std::string target, std::vector&amp;lt;std::string&amp;gt; searchVec) {
    int minIndex = 0;
    int maxIndex = searchVec.size();
    int guesses = 0;
    while (true) {
        guesses += 1;
        int indexGuess = (minIndex + maxIndex)/2;
        if (maxIndex &amp;lt; minIndex) {
            std::cout &amp;lt;&amp;lt; &amp;quot;not in list&amp;quot; &amp;lt;&amp;lt; std::endl;
            break;
        } else if (searchVec[indexGuess] == target) {
            std::cout &amp;lt;&amp;lt; &amp;quot;found it at pos &amp;quot; &amp;lt;&amp;lt; indexGuess &amp;lt;&amp;lt; std::endl;
            break;
        } else if (target &amp;gt; searchVec[indexGuess]) {
            minIndex = indexGuess + 1;
            std::cout &amp;lt;&amp;lt; &amp;quot;bigger&amp;quot; &amp;lt;&amp;lt; std::endl;
        } else if (target &amp;lt; searchVec[indexGuess]) {
            maxIndex = indexGuess - 1;
            std::cout &amp;lt;&amp;lt; &amp;quot;smaller&amp;quot; &amp;lt;&amp;lt; std::endl;
        }
    };
    std::cout &amp;lt;&amp;lt; &amp;quot;total guesses: &amp;quot; &amp;lt;&amp;lt; guesses &amp;lt;&amp;lt; std::endl;
}

int main() {
    std::vector&amp;lt;std::string&amp;gt; primeVec {&amp;quot;abs&amp;quot;, &amp;quot;babs&amp;quot;, &amp;quot;cabs&amp;quot;, &amp;quot;dabs&amp;quot;, &amp;quot;eabs&amp;quot;, &amp;quot;fabs&amp;quot;, &amp;quot;gabs&amp;quot;, &amp;quot;habs&amp;quot;};
    binarySearch(&amp;quot;fabs&amp;quot;, primeVec);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Failing the Whiteboard Interview</title>
      <link>http://ericlearns.com/post/failing-whiteboard-interview/</link>
      <pubDate>Tue, 09 May 2017 06:26:12 -0400</pubDate>
      
      <guid>http://ericlearns.com/post/failing-whiteboard-interview/</guid>
      <description>&lt;p&gt;Whiteboard interviews are tough. Although I work as a developer, I&amp;rsquo;ve never had a whiteboard interview until recently. I went on an interview for a Software Developer role at a company I was interested in, and the interview went pretty terrible&amp;hellip;particularly the whiteboard portion. It&amp;rsquo;s the same old story that&amp;rsquo;s been told a thousand times before- I was super nervous, the questions were basically puzzles unrelated to the job, and the interviewers (although experienced developers) were probably not experienced interviewers. All of this together resulted in:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Thanks for your interest, but we need someone with more experience.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This decision is of course based on the fact that I could only come up with brute force solutions to their puzzles and couldn&amp;rsquo;t name the asymptotic (Big O) runtimes, and not my ability to produce production ready code or my day to day development experience. Fair enough I guess. If they looked at actual code I&amp;rsquo;ve written and said&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Wow, this code is shit!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;then maybe I&amp;rsquo;d be more broken up about the whole thing, but that didn&amp;rsquo;t happen. Instead I got puzzles and frustrated interviewers. I did  actually study and practice prior to this interview, but I&amp;rsquo;ve come to the conclusion that trying to &lt;em&gt;learn&lt;/em&gt; new things in preperation for an interview is probably a bad idea and maybe even a red flag. Cramming isn&amp;rsquo;t going to make up for lack of experience. I am not saying that you shouldn&amp;rsquo;t prepare for an interview (far from it), but I think a good fit is going to come naturally with the experience and knowledge you already have.&lt;/p&gt;

&lt;p&gt;So what happens for me next? &lt;em&gt;Learn more and keep going&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This interview was definitely a failure and a blow to me, but it was also an awesome learning opportunity. I do not have a CS degree, so there are definitely some areas I am really lacking in and I need to address. I also got some great experience being up at the whiteboard and trying to work through a problem while someone (usually a more senior developer) watches on. It&amp;rsquo;s hard (impossible?) to replicate this scenario without actually being in an interview. At the end of the day I am going to get a lot from this interview failure because it&amp;rsquo;s going to push me even more to learn and grow. Maybe I should send someone a thank you for that? Eh, maybe not.&lt;/p&gt;

&lt;p&gt;So there are some things I am going to work on. Specifically, algorithms and data structures as well as studying up runtimes and optimizations. I&amp;rsquo;ll be doing a series of posts on what I&amp;rsquo;m learning, while writing solutions in &lt;code&gt;Python&lt;/code&gt; and &lt;code&gt;C++&lt;/code&gt; the best I can.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re reading this and you&amp;rsquo;ve recently had a technical interview that went poorly I&amp;rsquo;d encourage you to &lt;em&gt;really&lt;/em&gt; evaluate where the interview went wrong and what areas you can improve on. Although there was no job offer, and that hurts I know, you got a &lt;em&gt;huge&lt;/em&gt; amount of experience going through the process even if it doesn&amp;rsquo;t feel like it right now. Your efforts weren&amp;rsquo;t all for nothing.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Function Overloading - A Quick Intro</title>
      <link>http://ericlearns.com/post/function-overloading/</link>
      <pubDate>Sun, 16 Apr 2017 07:20:57 -0400</pubDate>
      
      <guid>http://ericlearns.com/post/function-overloading/</guid>
      <description>&lt;p&gt;C++ function overloading is an interesting concept. It allows you to create many functions with the same name but that take different arguments. The compiler knows which function you are referencing based on the arguments passed to the function. Hey, that&amp;rsquo;s pretty cool! Using my old friend &lt;code&gt;struct BikeRoute&lt;/code&gt; (remember the trailing &lt;code&gt;;&lt;/code&gt;) I&amp;rsquo;ll try out some basic function overloading:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

struct BikeRoute {
	int distance, watts;
	double time;
	std::string routeName;

        // member functions
	int accountForHills(int gradient, int multiplier);
	int accountForHills(int gradient, int timeMultiplier);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But there is a problem here. I defined the function &lt;code&gt;accountForHills&lt;/code&gt; that takes two &lt;code&gt;int&lt;/code&gt; parameters twice. Even though the parameter is &lt;em&gt;named&lt;/em&gt; differently, the compiler only knows which function I am referencing based on the parameter &lt;em&gt;type&lt;/em&gt;. The name of the parameter itself is meaningless to the compiler for function overloading reference purposes.&lt;/p&gt;

&lt;p&gt;Really though, the second instance of &lt;code&gt;accountForHills&lt;/code&gt; is not needed because it&amp;rsquo;s exactly the same as the first, but let&amp;rsquo;s say instead that there are some cases where I don&amp;rsquo;t need the &lt;code&gt;multiplier&lt;/code&gt; parameter and &lt;em&gt;only&lt;/em&gt; need the gradient. Now my code looks as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

struct BikeRoute {
	int distance, watts;
	double time;
	std::string routeName;

        // member functions
	int accountForHills(int gradient);

        // sometimes I pedal harder than usual, so use multiplier to account for effort
	int accountForHills(int gradient, int multiplier);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, let&amp;rsquo;s create the member functions and put everything together.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ov1.h&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

struct BikeRoute {
	int distance, watts;
	double time;
	std::string routeName;

        // member functions
	int accountForHills(int gradient);
        // sometimes I pedal harder than usual, so use multiplier to account for effort
	int accountForHills(int gradient, int multiplier);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ov1.cpp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;ov1.h&amp;quot;

int BikeRoute::accountForHills(int gradient) {
	return distance * gradient;
}

int BikeRoute::accountForHills(int gradient, int multiplier) {
	return (distance * gradient) * multiplier;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;main.cpp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;ov1.h&amp;quot;

int main() {
	BikeRoute dailyCommute = { 25, 450, 25.5, &amp;quot;Friday Commute&amp;quot; };
	int hillGradient = dailyCommute.accountForHills(2);
	int hillGradientWithMultiplier = dailyCommute.accountForHills(2, 2);

	std::cout &amp;lt;&amp;lt; &amp;quot;Distance factoring in hills: &amp;quot; &amp;lt;&amp;lt; hillGradient &amp;lt;&amp;lt; std::endl;
	std::cout &amp;lt;&amp;lt; &amp;quot;Distance factoring in hills and effort: &amp;quot; &amp;lt;&amp;lt; hillGradientWithMultiplier &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can compile this program from the command line with &lt;code&gt;g++ main.cpp ov1.cpp -o bikeCalcs.exe&lt;/code&gt;, and running the resulting executable called &lt;code&gt;bikeCalcs.exe&lt;/code&gt; will show the following in standard out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Distance factoring in hills: 50
Distance factoring in hills and effort: 100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now of course, this is a really simple example with calculations that don&amp;rsquo;t really make sense but the point was to show how C++ function overloading works, as well as building on my previous blog post on &lt;code&gt;C++ structs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Is function overloading possible in Python? Well, no not really. Python is &lt;em&gt;not&lt;/em&gt; statically typed, so there is no way to know which method is being referenced based on the arguments. Python does however lend itself to the concept of function overloading by allowing optional arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def account_for_hills(distance, gradient, multiplier=None):
    if multiplier:
        return (distance * gradient) * multiplier
    return distance * gradient
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not exactly the same as C++ function overloading, but I think it&amp;rsquo;s still similar and obviously useful. I think just as having many functions with the same name in C++ could get confusing and hard to maintain, having many optional arguments in a Python function will also become confusing and hard to maintain. It&amp;rsquo;s a give and a take in the end, extensibility vs readability as they say.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Starting Out With Structs</title>
      <link>http://ericlearns.com/post/starting-out-with-structs/</link>
      <pubDate>Thu, 13 Apr 2017 06:42:44 -0400</pubDate>
      
      <guid>http://ericlearns.com/post/starting-out-with-structs/</guid>
      <description>&lt;p&gt;From this point on I am going to write all my C++ programs with a minimum of 3 files: &lt;code&gt;main.cpp&lt;/code&gt; &lt;code&gt;headerFile.h&lt;/code&gt; &lt;code&gt;logicFile.cpp&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;main.cpp&lt;/code&gt; and &lt;code&gt;logicFile.cpp&lt;/code&gt; will contain an &lt;code&gt;#include headerFile.h&lt;/code&gt; statement at the top. This seems like the best way to keep everything organized, as well as a C++ best practice.&lt;/p&gt;

&lt;p&gt;So, with that out of way let&amp;rsquo;s talk about &lt;code&gt;structs&lt;/code&gt;. A &lt;code&gt;struct&lt;/code&gt; is a C++ data structure that allows you to store different &lt;em&gt;types&lt;/em&gt; of variables together in one place (encapsulation anyone?). That seems pretty handy, but it also seems very similar to a class&amp;hellip;.and it turns out that a &lt;code&gt;struct&lt;/code&gt; is &lt;em&gt;very&lt;/em&gt; similar to a &lt;code&gt;class&lt;/code&gt; in C++. The primary difference between the two being that anything in a &lt;code&gt;struct&lt;/code&gt; is &lt;code&gt;public&lt;/code&gt; by default.&lt;/p&gt;

&lt;p&gt;Ok, interesting. But what does &lt;code&gt;public&lt;/code&gt; mean, and why should I care? &lt;code&gt;public&lt;/code&gt; means that anything in a &lt;code&gt;struct&lt;/code&gt; can be accessed and modified by another function. Sometimes we don&amp;rsquo;t want things in our structs (or classes) to be accessed and modified because when I go to use that thing somewhere else, it might not do or return what I am expecting it to as it is defined. This is where &lt;code&gt;private&lt;/code&gt; comes in, but this is a post for another time. Back to &lt;code&gt;struct&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In my header file &lt;code&gt;structDemo.h&lt;/code&gt; I will create the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

struct BikeRoute {
    int distance, watts;
    std::string routeName;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we defined a &lt;code&gt;struct&lt;/code&gt; named &lt;code&gt;BikeRoute&lt;/code&gt; that has 3 members: &lt;code&gt;int distance&lt;/code&gt; &lt;code&gt;int watts&lt;/code&gt; and &lt;code&gt;string routeName&lt;/code&gt;. One really important point is the &lt;em&gt;trailing semi-colon&lt;/em&gt;. In C++, &lt;code&gt;struct&lt;/code&gt;&amp;rsquo;s must have a trailing semi-colon. I &lt;em&gt;always&lt;/em&gt; forget this.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;main.cpp&lt;/code&gt; I&amp;rsquo;ll add the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;structDemo.h&amp;quot;

int main() {
    BikeRoute tuesdayRide = { 24, 450, &amp;quot;Daily Commute&amp;quot; };
    std::cout &amp;lt;&amp;lt; tuesdayRide.distance &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I am &lt;code&gt;instantiating&lt;/code&gt; the &lt;code&gt;struct&lt;/code&gt; named &lt;code&gt;BikeRoute&lt;/code&gt; and setting the values for distance, watts, and routeName that represent my &lt;code&gt;tuesdayCommute&lt;/code&gt; in this case. Compiling this program and running the output file would print &lt;code&gt;24&lt;/code&gt; to standard out. I could have also definied each member like this (shortened):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;...
BikeRoute tuesdayRide;
tuesdayRide.distance = 24;
tuesdayRide.watts = 450;
tuesdayRide.routeName = &amp;quot;Daily Commute;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point I have a file called &lt;code&gt;structDemo.cpp&lt;/code&gt; that is empty. In my &lt;code&gt;main&lt;/code&gt; function I am sending the distance I rode to standard out. I think it would be nice to have a function that printed the details of my ride in a nice format. Let&amp;rsquo;s add a &lt;em&gt;member function&lt;/em&gt; to the BikeRoute &lt;code&gt;struct&lt;/code&gt;. In &lt;code&gt;structDemo.h&lt;/code&gt; I&amp;rsquo;ll add a reference to the yet to be created function &lt;code&gt;prettyPrint();&lt;/code&gt;, which will display a nicely formatted output to standard out. Adding the new function to the struct tells the compiler that &lt;code&gt;prettyPrint()&lt;/code&gt; is a &lt;em&gt;member&lt;/em&gt; function, and it is going to reference items in the BikeRoute &lt;code&gt;struct&lt;/code&gt;. My header file now looks as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

struct BikeRoute {
	int distance, watts;
	std::string routeName;

	// member function
	void Time::prettyPrint();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And in &lt;code&gt;structDemo.cpp&lt;/code&gt; I&amp;rsquo;ll create the &lt;code&gt;prettyPrint()&lt;/code&gt; function. Note the &lt;code&gt;#include &amp;quot;structDemo.h&lt;/code&gt; at the top of the file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;quot;structDemo.h&amp;quot;

void BikeRoute::prettyPrint() {
	std::cout &amp;lt;&amp;lt; &amp;quot;Route Name: &amp;quot; &amp;lt;&amp;lt; routeName &amp;lt;&amp;lt; std::endl;
	std::cout &amp;lt;&amp;lt; &amp;quot;Distance: &amp;quot; &amp;lt;&amp;lt; distance &amp;lt;&amp;lt; std::endl;
	std::cout &amp;lt;&amp;lt; &amp;quot;Watts: &amp;quot; &amp;lt;&amp;lt; watts &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now what&amp;rsquo;s pretty cool here is that I just used &lt;code&gt;routeName&lt;/code&gt;, &lt;code&gt;distance&lt;/code&gt; and &lt;code&gt;watts&lt;/code&gt; directly. I didn&amp;rsquo;t need to instantiate BikeRoute to access them because &lt;code&gt;prettyPrint()&lt;/code&gt; is a member function and the compiler knows where to look to get the values.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;main.cpp&lt;/code&gt; I have the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;structDemo.h&amp;quot;

int main() {
	BikeRoute tuesdayRide = { 24, 450, &amp;quot;Daily Commute&amp;quot; };
	tuesdayRide.prettyPrint();

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here I instantiate an instance of BikeRoute, and &lt;code&gt;call&lt;/code&gt; the member function &lt;code&gt;prettyPrint&lt;/code&gt;. To compile this program I&amp;rsquo;ll run &lt;code&gt;g++ main.cpp structDemo.cpp&lt;/code&gt; from the command line, then run the executable which outputs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Route Name: Daily Commute
Distance: 24
Watts: 450
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This was a really simple example just to get my feet wet with C++ structs, which is a data structure whos equivalent I haven&amp;rsquo;t really come across in Python. I think I would just use a &lt;code&gt;class&lt;/code&gt; in Python, and I think eventually in C++ you just end up using a &lt;code&gt;class&lt;/code&gt; too but I am sure there are good use cases for structs.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning About the g&#43;&#43; Compiler</title>
      <link>http://ericlearns.com/post/learning-about-the-compilier/</link>
      <pubDate>Mon, 10 Apr 2017 20:32:38 -0400</pubDate>
      
      <guid>http://ericlearns.com/post/learning-about-the-compilier/</guid>
      <description>&lt;p&gt;Being that C++ is a &lt;em&gt;compiled&lt;/em&gt; language, we need a &lt;em&gt;compiler&lt;/em&gt; to &lt;em&gt;compile&lt;/em&gt; our code. Phew. For reasons that are not yet clear to me, my computers (Windows &amp;amp; Linux) have &lt;code&gt;g++&lt;/code&gt; already installed on them, so that&amp;rsquo;s what I&amp;rsquo;ve been using. &lt;code&gt;g++&lt;/code&gt; is used primarily via the command line, and takes a few arguments including file names and an output flag. Let&amp;rsquo;s write a simple C++ program and tinker with compiling it. I&amp;rsquo;ll go ahead and create a new file called &lt;code&gt;awesomeCalc.cpp&lt;/code&gt; and add the code below. The program just does a simple tax calculation and prints the results to the command line.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

int taxCalc(int price, float taxRate) {
    return price + (price * taxRate);
}

void printTotalPrice() {
    int totalPaid = taxCalc(100, .15);  // $100 at a 15% tax rate
    std::cout &amp;lt;&amp;lt; &amp;quot;Total price: &amp;quot; &amp;lt;&amp;lt; &amp;quot;$&amp;quot; &amp;lt;&amp;lt; totalPaid &amp;lt;&amp;lt; std::endl;
}

int main() {
    printTotalPrice();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, if I wanted to &lt;em&gt;compile&lt;/em&gt; this program I would move the location of the file using the command line and type the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;g++ awesomeCalc.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far so good, but what just happened? The compiler went through the code, checked for errors, translated our C++ code to &lt;em&gt;machine code&lt;/em&gt;, and created an output file (usually) called &lt;code&gt;a.out&lt;/code&gt; or &lt;code&gt;a.exe&lt;/code&gt; depending on the operating system. You could run the executable from the command line at this point if you wanted:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;a.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which should output the following text in the command prompt:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Total price: $115
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nice. But I&amp;rsquo;d like to call the output file something other than &lt;code&gt;a.exe&lt;/code&gt;. How about &lt;code&gt;taxCalculator.exe&lt;/code&gt;? Back in the command prompt I need to &lt;em&gt;re-compile&lt;/em&gt; the code with the &lt;code&gt;g++&lt;/code&gt; optional flag &lt;code&gt;-o&lt;/code&gt; and the filename of my choice.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;g++ awesomeCalc.cpp -o taxCalculator.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now there is a new executable file with the much more &lt;em&gt;meaningful&lt;/em&gt; name &lt;code&gt;taxCaculator.exe&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Things get a little more complicated when there are multiple files to compile. For example, a &lt;code&gt;header&lt;/code&gt; file, a &lt;code&gt;main&lt;/code&gt; file, and &lt;code&gt;logic&lt;/code&gt; file. I&amp;rsquo;ll probably look back at this scenario more in depth pretty soon, but I started writing my C++ programs in multiple files like this recently to keep everything organized (it also seems like best practice) and I really like it. At first I had a hard time figuring out how to get my code to compile though. My code fed into the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;main&lt;/code&gt; files, but when I ran&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;g++ main.cpp -o awesomeProgram.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I was greeted with a couple pages of error messages. It turns out that what I needed to do instead is compile &lt;code&gt;main.cpp&lt;/code&gt; with the logic file for my program &lt;code&gt;myAwesomeProgram.cpp&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;g++ main.cpp myAwesomeProgram.cpp -o awesomeProgram.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes! No pages of errors, and my executable is created. Does the order of the files matter when you compile? As far as I can tell it &lt;em&gt;usually&lt;/em&gt; does not, but this could be a nice surprise for me in the near future.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;g++ myAwesomeProgram.cpp main.cpp -o awesomeProgram.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It turns out that in C++ when you are &lt;code&gt;linking&lt;/code&gt; files using &lt;code&gt;g++&lt;/code&gt; (e.g. including &lt;code&gt;coolExistingFile.o&lt;/code&gt;), the order is very important because one of the &lt;code&gt;.cpp&lt;/code&gt; files could depend on what is in &lt;code&gt;coolExistingFile.o&lt;/code&gt; and needs to reference it first. I haven&amp;rsquo;t had a need to use &lt;code&gt;linking&lt;/code&gt; yet, so for now I am throwing my file names at &lt;code&gt;g++&lt;/code&gt; in whatever order I want.&lt;/p&gt;

&lt;p&gt;Up until I recently started learning C++ I have only worked with &lt;em&gt;interpreted&lt;/em&gt; langauges, so all of this is very new to me. Among other things in C++, I actually really like compiling and checking for errors. The error output in C++ is a huge change from what I&amp;rsquo;m used to seeing in Python but it is teaching me to read the tracebacks very carefully. It seems to be helping me be more careful when writing my code because I have this lingering fear of a 10 page error output from &lt;code&gt;g++&lt;/code&gt;. I tell myself:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Be diligent and check everything over in the code, or face the consequences of trying to understand an enourmous error output at compile time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Obviously, I could get pages of error messages no matter how thoroughly I check over my code before compiling, but I think it does helps my code quality and code writing efficiency a little bit. Sometimes fear is a good motivator I guess.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Closer Look At Namespaces</title>
      <link>http://ericlearns.com/post/closer-look-at-namespaces/</link>
      <pubDate>Sat, 08 Apr 2017 07:06:45 -0400</pubDate>
      
      <guid>http://ericlearns.com/post/closer-look-at-namespaces/</guid>
      <description>&lt;p&gt;According to &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/5cb46ksf.aspx&#34;&gt;Microsoft&amp;rsquo;s C++ Language Reference&lt;/a&gt;, C++ namespaces are (more or less):&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A declarative region that provides a scope to types, functions, variables, etc inside it. Namespaces are used to organize code into logical groups and to prevent name collisions when working with a code base that includes multiple libraries.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, C++ namespaces are used to organize your code and prevent duplicate names (collisions). Got it.&lt;/p&gt;

&lt;p&gt;When I first started working in C++ I was writing &lt;code&gt;using namespace std;&lt;/code&gt; at the top of my files. It turns out that this can be a bad idea for more than a few reasons. The main reason being &lt;code&gt;name collisions&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;using namespace awesome1;
using namespace awesome2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example above (modified from &lt;a href=&#34;http://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice&#34;&gt;this SO post&lt;/a&gt;) if &lt;code&gt;namespace awesome2&lt;/code&gt; got an update that included a function named exactly the same as a function that exists in &lt;code&gt;namespace awesome1&lt;/code&gt; and you were using said function somewhere in your code, you now have a collision. I would expect to see a lengthy error output from the compiler telling me that there is a problem.&lt;/p&gt;

&lt;p&gt;The first C++ &lt;a href=&#34;http://www.greenteapress.com/thinkcpp/&#34;&gt;tutorial&lt;/a&gt; I worked through had me putting &lt;code&gt;using namespace std;&lt;/code&gt; at the top of my files, as I mentioned above. While this isn&amp;rsquo;t &lt;em&gt;terrible&lt;/em&gt; in practice, it&amp;rsquo;s also not ideal. To make declarations more clear, and to avoid potential name collisions, I switched over to prepending &lt;code&gt;std::&lt;/code&gt; to my declarations instead.&lt;/p&gt;

&lt;p&gt;Using the prepend (&lt;code&gt;std::cout&lt;/code&gt; for example) you&amp;rsquo;re basically saying:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hey, I&amp;rsquo;m using a reference to something that lives somewhere else! But, let me tell you exactly where it comes from. I&amp;rsquo;ll also do you the nice favor of not bringing in a bunch of other things that might not be needed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &amp;ldquo;not bringing in a bunch of other things&amp;rdquo; is an important point too. It&amp;rsquo;s better to bring in exactly what you need instead of cluttering up the namespace with &lt;em&gt;everything&lt;/em&gt; in the given library. This can get confusing pretty quickly. I&amp;rsquo;m picturing the equivalent in Python:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pymongo import *  # Now I have tons of things I don&#39;t need and don&#39;t know about. Dang.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;vs&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pymongo import MongoClient  # I only need this thing right now and nothing else. Awesome!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In C++, this looks something like the example code below. Adding the prepend &lt;code&gt;std::&lt;/code&gt; (or others) is very tedious as I found out, but I think it does make the code more readable in the long run.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

int main() {
    int awesomeIntVar = 100;
    std::cout &amp;lt;&amp;lt; &amp;quot;My awesome int variable: &amp;quot; &amp;lt;&amp;lt; awesomeIntVar &amp;lt;&amp;lt; std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another reasonable alternative is the &lt;code&gt;using&lt;/code&gt; directive:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using std::cout;
using std::endl;

int main() {
    int awesomeIntVar = 100;
    cout &amp;lt;&amp;lt; &amp;quot;My awesome int variable: &amp;quot; &amp;lt;&amp;lt; awesomeIntVar &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But how much is the &lt;code&gt;using&lt;/code&gt; directive pattern above really saving me? Am I giving up some &lt;em&gt;code readability&lt;/em&gt; in exchange for a slight convenience? I think I&amp;rsquo;ll stick with the &lt;em&gt;tedious&lt;/em&gt; explicit declaration for now.&lt;/p&gt;

&lt;p&gt;Apparently &lt;code&gt;using namespace ...&lt;/code&gt; or using &lt;code&gt;using std::cout&lt;/code&gt; (for example) is a big no-no in header files. Similar to the above scenarios, this can cause major name collisions. The &lt;a href=&#34;http://stackoverflow.com/questions/4872373/why-is-including-using-namespace-into-a-header-file-a-bad-idea-in-c&#34;&gt;example&lt;/a&gt; below shows what happened if I decided for some silly reason to create a &lt;code&gt;struct&lt;/code&gt; named &lt;code&gt;string&lt;/code&gt; with the &lt;code&gt;std&lt;/code&gt; namespace declared and &lt;code&gt;#include &amp;lt;string&amp;gt;&lt;/code&gt;. The compiler has no clue which &lt;code&gt;string&lt;/code&gt; to use, and you get an error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;string&amp;gt;
using namespace std;

struct string {const char* p;};  // hmm, probably a bad name choice

int main() {
    // declare a string....but from where? Error.
    string x;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;But wait, there&amp;rsquo;s more!&lt;/em&gt; You can (and should) declare your own namespaces in C++!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

namespace awesomeNamespace {
    // whatever variable you need!
    int height = 300;
}

namespace coolFunc {
    // functions too!
    void func() {
        std::cout &amp;lt;&amp;lt; &amp;quot;heck yeah&amp;quot; &amp;lt;&amp;lt; std:: endl;
    }
}

int main() {
    std::cout &amp;lt;&amp;lt; awesomeNamespace::height &amp;lt;&amp;lt; std::endl;
    coolFunc::func();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why would you want to declare your own namespace? Well, I think this would help differentiate functions with the same name in the same space. If you use the namespace prepend, you can let the compiler know exactly which function you are referring to. Brilliant.&lt;/p&gt;

&lt;p&gt;All this C++ namespace research got me wondering about namespaces in Python. Is there such a thing as a Python namespace? Well, yes but it works much differently than C++ namespaces. Python has &lt;code&gt;local&lt;/code&gt; and &lt;code&gt;global&lt;/code&gt; namespaces. A &lt;code&gt;local&lt;/code&gt; namespace exists in a package, module, class, or function. A &lt;code&gt;global&lt;/code&gt; namespace exists outside of the &lt;code&gt;local&lt;/code&gt; namespace when a name cannot be found in the &lt;code&gt;local&lt;/code&gt; namespace. This wonderful &lt;a href=&#34;http://stackoverflow.com/questions/3913217/what-are-python-namespaces-all-about?answertab=votes#tab-top&#34;&gt;SO answer&lt;/a&gt; sums it up nicely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Things I Know, Things I Don&#39;t Know, and Things I&#39;m Avoiding</title>
      <link>http://ericlearns.com/post/things-i-know-things-dont-know/</link>
      <pubDate>Thu, 06 Apr 2017 20:47:16 -0400</pubDate>
      
      <guid>http://ericlearns.com/post/things-i-know-things-dont-know/</guid>
      <description>&lt;p&gt;Let me get the thing I&amp;rsquo;m avoiding in C++ out of the way first: &lt;em&gt;Pointers&lt;/em&gt;. I recently read an article that boldy proclaimed&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;C++ pointers are easy and fun to learn!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hmm, this is a strange assertion and I&amp;rsquo;m not entirely convinced that the person who made this statement was entirely in their right mind. To me, pointers are very foreign concept. Even just googling &amp;ldquo;what is a pointer C++?&amp;rdquo; lead me to find many different definitions of &lt;em&gt;what&lt;/em&gt; a pointer actually is. Here is my best definition of a pointer for right now&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A variable that stores the (memory) address of another variable&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;That seems simple enough but I know that&amp;rsquo;s not all there is to it, so I am storing pointers under &amp;ldquo;Things I&amp;rsquo;m Avoiding&amp;rdquo; for now.&lt;/p&gt;

&lt;p&gt;How about some things I know? Well, I know that C++ is a &lt;em&gt;statically typed&lt;/em&gt; language, and all variable types must be defined as a result of this. Compared to Python and JavaScript (&lt;em&gt;dynamically typed&lt;/em&gt;) where basically anything goes, this is a bit of a change. But I will say that after writing some C++ for few days that having no option but to define the type is sort of refreshing. It&amp;rsquo;s nice to know exactly what is going in and what being returned.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int myInt, myOtherInt;
bool myBool;

int awesomeBool() {
    ...
    return 100;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another thing I know, but maybe don&amp;rsquo;t fully understand yet is the &lt;code&gt;main&lt;/code&gt; function. Another foreign concept to me, but it&amp;rsquo;s essentially the &lt;em&gt;entry point&lt;/em&gt; for the program. It must also &lt;em&gt;usually&lt;/em&gt; return an &lt;code&gt;int&lt;/code&gt; even if the &lt;code&gt;int&lt;/code&gt; is just a placeholder zero.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int main() {
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, &lt;code&gt;main&lt;/code&gt; also exists in Python but it&amp;rsquo;s not really as common and there is no entry point enforcement really. A more common idiom in Python is the &lt;code&gt;if __name__ == &#39;__main__:&lt;/code&gt;, which can take a function named &lt;code&gt;main&lt;/code&gt; or any object of your choice.&lt;/p&gt;

&lt;p&gt;Lastly, something I don&amp;rsquo;t fully understand yet are vectors. I know that vectors are a very important data structure in C++, but I can&amp;rsquo;t stop picturing them as Python dictionaries&amp;hellip;.or maybe a list? They are accessed in a similar fashion to a Python list, but they&amp;rsquo;re not exactly the same. You can iterate them, add (read &lt;code&gt;push_to&lt;/code&gt;) them, and even &lt;em&gt;nest&lt;/em&gt; them. They also need to be &lt;code&gt;#include&lt;/code&gt;&amp;rsquo;d when they&amp;rsquo;re used. Very handy, but I need to explore more.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An Intro of Sorts</title>
      <link>http://ericlearns.com/post/an-intro-of-sorts/</link>
      <pubDate>Wed, 05 Apr 2017 20:57:36 -0400</pubDate>
      
      <guid>http://ericlearns.com/post/an-intro-of-sorts/</guid>
      <description>&lt;p&gt;So, I recently decided that I&amp;rsquo;d like to learn C++. Maybe not to become an expert C++ developer, which I assume takes many years, but to be comfortable enough
in the language to have it be useful. I think &amp;ldquo;proficient in C++&amp;rdquo; would be the right way to put it. The purpose of this blog will be for me to track my thoughts
and learning, and I also thought there might be someone else out there like me trying to learn who wants to follow along&amp;hellip;or sympathize with me.&lt;/p&gt;

&lt;p&gt;I should say up front that I am not learning C++ as a &lt;em&gt;new&lt;/em&gt; developer. I am (what I would consider) a relatively experienced Python and JavaScript (Node.js) developer.
In fact, I currently write code for a living. C++ always seemed like some monstrous beast of a language that was too difficult or not worth the tremendous effort to learn. I think I&amp;rsquo;ve
come to a point where learning C++ would help me improve as a developer, so why not give it a shot.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll probably see me make reference to idioms and patterns in python &lt;em&gt;a lot&lt;/em&gt;. Python is currently my favorite language, but it is obviously &lt;em&gt;very&lt;/em&gt; different than C++ in many ways. You will
probably also see me make egregious errors in C++, things that would make a seasoned C++ developer cry out in pain. I think this is part of the learning process, and it&amp;rsquo;s important to make mistakes while
learning new things, especially programming languages. With that being said, anything I write should NOT be used as a reference or tutorial of any sort. I mostly have no idea what I&amp;rsquo;m doing.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>